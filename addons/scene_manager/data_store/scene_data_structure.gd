@tool
class_name SMgrData
extends Resource

## Signal emitted when scene management data changes
signal data_changed
## Signal emitted when the state of the dirty flag (unsaved changes) changes
## @param dirty Current dirty state
signal on_dirty_flag_changed(dirty: bool)


## Key constants for parsing within the generated file
class CommentKey:
	const ENUM: String = "# [Scene Enum]"


## Header text for the autogenerated scene data file
const SCENE_DATA_HEADER: String = """#
# This file is autogenerated by the Scene Manager plugin.
# DO NOT EDIT.
#
@tool
extends Node

"""
const AF = preload("uid://dlgh4u64a7qxk")

## List of directory paths to include
@export var _include_list: Array[String]
## Dictionary of scene data objects keyed by scene UID (int)
@export var _scenes: Dictionary[int, SMgrDataScene]
## List of section (category) names
@export var _sections: Array[String]

## Flag indicating whether there are unsaved changes
var _dirty_flag: bool = false:
	set(value):
		if _dirty_flag != value:
			_dirty_flag = value
			on_dirty_flag_changed.emit.call_deferred(value)
	get():
		return _dirty_flag


func _init() -> void:
	data_changed.connect(func() -> void: _dirty_flag = true)
	# Setup filesystem monitoring if running within the editor
	if Engine.is_editor_hint():
		setup_filesystem_monitoring.call_deferred()


# --- Internal Methods (Private) ---


## Setup monitoring for filesystem changes
func setup_filesystem_monitoring() -> void:
	var fs := EditorInterface.get_resource_filesystem()
	if not fs.filesystem_changed.is_connected(_on_filesystem_changed):
		fs.filesystem_changed.connect(_on_filesystem_changed)


## Callback triggered when the filesystem changes (file added, removed, moved, etc.)
func _on_filesystem_changed() -> void:
	# Automatically scan and sync new files within include paths
	sync_with_filesystem()


func _export_enum_gd_string() -> String:
	var ret: String = SCENE_DATA_HEADER
	ret += CommentKey.ENUM + "\n"
	ret += "enum Id \\\n{ \n\tNONE = -1,"

	var num_invalid: int = 0
	for uid in _scenes:
		var sc_name := _scenes[uid].name
		ret += "\n\t%s," % sc_name.to_upper()
	ret += "\n}\n"
	return ret


func save_data(path: String, data_path: String) -> void:
	# --- write GDScript(Enum) data ---
	var file := FileAccess.open(path, FileAccess.WRITE)
	if not file:
		printerr("Scene Manager Error: Failed to open file for writing at '%s'." % path)
		return
	file.store_string(_export_enum_gd_string())
	file.close()

	# --- save this resource itself ---
	var error := ResourceSaver.save(self, data_path)
	if error != OK:
		printerr(
			(
				"Scene Manager Error: Failed to save SMgrData resource at '%s' (Error: %d)."
				% [data_path, error]
			)
		)

	_dirty_flag = false


# --- File System Sync ---
## Rescans registered include paths, removes non-existent scenes, and registers new scenes
func sync_with_filesystem() -> void:
	var found_uids: Array[int] = []
	var changed := false

	# Scan each path in the include list
	for path in _include_list:
		if DirAccess.dir_exists_absolute(path):
			_scan_and_collect_uids(path, found_uids)
		elif FileAccess.file_exists(path) and path.ends_with(".tscn"):
			var uid := _register_scene_file(path)
			if uid != ResourceUID.INVALID_ID:
				found_uids.append(uid)

	# Remove UIDs that should be under the include list but were not found during the scan
	var uids_to_remove: Array[int] = []
	for uid in _scenes:
		var scene_path := _scenes[uid].path
		# Check if the scene is managed under any of the current include paths
		var is_managed := false
		for inc_path in _include_list:
			if scene_path.begins_with(inc_path):
				is_managed = true
				break

		# If managed but not found on the filesystem, mark for removal
		if is_managed and not uid in found_uids:
			uids_to_remove.append(uid)

	if not uids_to_remove.is_empty():
		for uid in uids_to_remove:
			_scenes.erase(uid)
		changed = true

	# Although data_changed is emitted inside _register_scene_file when a file is added,
	# we emit it here to ensure notification if deletions occurred.
	if changed:
		data_changed.emit()


## For scanning: Recursively collects UIDs
func _scan_and_collect_uids(dir_path: String, collected_uids: Array[int]) -> void:
	var dir: DirAccess = DirAccess.open(dir_path)
	if not dir:
		return

	dir.list_dir_begin()
	var file_name: String = dir.get_next()
	while file_name != "":
		var full_path: String = dir_path.path_join(file_name)
		if dir.current_is_dir():
			if file_name != "." and file_name != "..":
				_scan_and_collect_uids(full_path, collected_uids)
		elif file_name.ends_with(".tscn"):
			var uid = _register_scene_file(full_path)
			if uid != ResourceUID.INVALID_ID:
				collected_uids.append(uid)
		file_name = dir.get_next()


# --- Section Management ---


## Adds a new section
## @param section_name Name of the section to add
func add_section(section_name: String) -> void:
	if not section_name.is_empty() and not _sections.has(section_name):
		_sections.append(section_name)
		data_changed.emit()


## Removes a section and clears its references from all associated scenes
## @param section_name Name of the section to remove
func remove_section(section_name: String) -> void:
	if _sections.has(section_name):
		_sections.erase(section_name)
	else:
		printerr("Scene Manager Error: Cannot remove section '%s'." % section_name)
		return

	for uid in _scenes:
		var scene_info: SMgrDataScene = _scenes[uid]
		var index := scene_info.sections.find(section_name)
		if index != -1:
			scene_info.sections.remove_at(index)
	data_changed.emit()


# --- Include List Management ---


## Adds an include path and scans the target directory or file
## @param inc_path Path to add
## @return true if successful
func add_include_path(inc_path: String) -> bool:
	var is_dir := DirAccess.dir_exists_absolute(inc_path)
	var is_file := FileAccess.file_exists(inc_path) and inc_path.ends_with(".tscn")

	if not is_dir and not is_file:
		push_warning(
			"Scene Manager Error: Path '%s' is not a valid directory or .tscn file." % inc_path
		)
		return false

	# Check for inclusion relationships
	for existing_path in _include_list:
		if inc_path.begins_with(existing_path):
			var msg := (
				"Scene Manager: Path '%s' is already covered by '%s'." % [inc_path, existing_path]
			)
			push_warning(msg)  # Shows in the editor's Warning tab
			return false

	# If the new path is a parent of existing paths, remove those sub-paths
	var original_size := _include_list.size()
	_include_list = _include_list.filter(
		func(p: String) -> bool: return not p.begins_with(inc_path)
	)

	if _include_list.size() < original_size:
		print("Scene Manager: Removed sub-paths that are now covered by '%s'." % inc_path)

	# Add to list and execute scan
	_include_list.append(inc_path)
	if is_dir:
		_scan_dir_recursive(inc_path)
	else:
		_register_scene_file(inc_path)

	data_changed.emit()
	print("Scene Manager: Successfully added path '%s'." % inc_path)
	return true


## Recursively scans a directory and registers .tscn files
## @param dir_path Path to scan
func _scan_dir_recursive(dir_path: String) -> void:
	var dir: DirAccess = DirAccess.open(dir_path)
	if not dir:
		return

	dir.list_dir_begin()
	var file_name: String = dir.get_next()

	while file_name != "":
		var full_path: String = dir_path.path_join(file_name)

		if dir.current_is_dir():
			if file_name != "." and file_name != "..":
				_scan_dir_recursive(full_path)
		elif file_name.ends_with(".tscn"):
			_register_scene_file(full_path)

		file_name = dir.get_next()


## Registers a scene file based on its UID
## @param full_path Full path to the scene file
## @return Registered UID (even if it already existed)
func _register_scene_file(full_path: String) -> int:
	var uid := ResourceLoader.get_resource_uid(full_path)
	if uid == ResourceUID.INVALID_ID:
		return ResourceUID.INVALID_ID

	# Skip if the UID is already registered
	if _scenes.has(uid):
		return uid

	var base_name: String = full_path.get_file().get_basename()
	var scene_name: String = base_name

	# Handle duplicate names to ensure unique Enum keys
	var existing_names: Array = []
	for s in _scenes.values():
		existing_names.append(s.name)

	var counter: int = 1
	while scene_name in existing_names:
		scene_name = base_name + str(counter)
		counter += 1

	var new_scene := SMgrDataScene.new()
	new_scene.name = scene_name
	new_scene.path = full_path
	new_scene.uid = uid  # Stored as an int
	_scenes[uid] = new_scene
	data_changed.emit()
	return uid


## Removes an include path and unregisters all scenes under it
## @param scene_path Path to remove
func remove_include_path(scene_path: String) -> void:
	if _include_list.has(scene_path):
		_include_list.erase(scene_path)
	else:
		printerr(
			(
				"Scene Manager Error: Cannot remove include path. Path '%s' is not in the list."
				% scene_path
			)
		)
		return

	var uids_to_remove: Array[int] = []
	for uid in _scenes:
		if _scenes[uid].path.begins_with(scene_path):
			uids_to_remove.append(uid)

	for uid in uids_to_remove:
		_scenes.erase(uid)

	data_changed.emit()


# --- Data Queries (Getters) ---
func _get_scene_from_enum(scene: Scenes.Id) -> SMgrDataScene:
	if scene == Scenes.Id.NONE:
		return null
	var key_str: String = Scenes.Id.keys()[scene + 1]
	for uid in _scenes:
		var sc := _scenes[uid]
		if SceneManagerUtils.sanitize_as_enum_string(sc.name) == key_str:
			return sc
	return null


## Retrieves scene data by UID
## @param uid Scene UID (int)
## @return Corresponding SMgrDataScene
func get_scene_from_uid(uid: int) -> SMgrDataScene:
	return _scenes.get(uid, null)


## Retrieves a scene path from an enum key
## @param scene Scene enum
## @return Scene path string
func get_scene_path_from_enum(scene: Scenes.Id) -> String:
	var sc := _get_scene_from_enum(scene)
	return sc.path if sc else ""


## Retrieves an enum key from a scene path
## @param path Full path of the scene
## @return Corresponding Id
func get_scene_enum_by_path(path: String) -> Scenes.Id:
	for uid in _scenes:
		if _scenes[uid].path == path:
			var enum_name := SceneManagerUtils.sanitize_as_enum_string(_scenes[uid].name)
			return Scenes.Id.get(enum_name, Scenes.Id.NONE)
	return Scenes.Id.NONE


## Retrieves the full include list
## @return Array of paths
func get_include_list() -> Array[String]:
	return _include_list


## Retrieves the full list of sections
## @return Array of section names
func get_sections_list() -> Array[String]:
	return _sections


## Internal method to extract scenes into an array based on a comparison function
## @param cmp Callable for evaluation
## @return Filtered array of scenes
func _get_scenes(cmp: Callable) -> Array[SMgrDataScene]:
	var ret: Array[SMgrDataScene] = []
	for uid in _scenes:
		var sc := _scenes[uid]
		if cmp.call(sc):
			ret.append(sc)
	return ret


## Retrieves all registered scenes
## @return Array of scene data
func get_scenes_all() -> Array[SMgrDataScene]:
	return _get_scenes(func(sc: SMgrDataScene) -> bool: return true)


## Retrieves scenes that are not categorized
## @return Array of scene data
func get_scenes_uncategorized() -> Array[SMgrDataScene]:
	return _get_scenes(func(sc: SMgrDataScene) -> bool: return sc.sections.is_empty())


## Retrieves scenes that are categorized
## @return Array of scene data
func get_scenes_categorized() -> Array[SMgrDataScene]:
	return _get_scenes(func(sc: SMgrDataScene) -> bool: return not sc.sections.is_empty())


## Retrieves scenes belonging to a specific section
## @param section_name Name of the section to search for
## @return Array of scene data
func get_scenes_with_section(section_name: String) -> Array[SMgrDataScene]:
	return _get_scenes(func(sc: SMgrDataScene) -> bool: return section_name in sc.sections)


## Assigns a scene to a specific section
## @param uid Scene UID (int)
## @param section_name Name of the section to assign
func add_scene_to_section(uid: int, section_name: String) -> void:
	if _scenes.has(uid):
		var sc: SMgrDataScene = _scenes[uid]
		if not section_name in sc.sections:
			sc.sections.append(section_name)
			data_changed.emit()


## Removes a specific section assignment from a scene
## @param uid Scene UID (int)
## @param section_name Name of the section to remove
func remove_scene_from_section(uid: int, section_name: String) -> void:
	if _scenes.has(uid):
		var sc: SMgrDataScene = _scenes[uid]
		var idx := sc.sections.find(section_name)
		if idx != -1:
			sc.sections.remove_at(idx)
			data_changed.emit()


## Retrieves scene data by specifying a name
## @param scene_name Scene name
## @return Corresponding SMgrDataScene
func get_scene_by_name(scene_name: String) -> SMgrDataScene:
	for uid in _scenes:
		var sc: SMgrDataScene = _scenes[uid]
		if sc.name == scene_name:
			return sc
	return null


## Changes the display name of a scene
## @param uid Scene UID (int)
## @param new_name New display name
func change_scene_name(uid: int, new_name: String) -> void:
	if _scenes.has(uid):
		var sc: SMgrDataScene = _scenes[uid]
		if not new_name.is_empty() and sc.name != new_name:
			sc.name = new_name
			data_changed.emit()


## Retrieves the current dirty flag
## @return true if there are changes
func get_dirty_flag() -> bool:
	return _dirty_flag
