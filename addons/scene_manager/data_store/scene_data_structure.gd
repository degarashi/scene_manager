@tool
class_name SMgrData
extends RefCounted

## Signal emitted when scene management data changes
signal data_changed
## Signal emitted when the state of the dirty flag (unsaved changes) changes
## @param dirty Current dirty state
signal on_dirty_flag_changed(dirty: bool)


## Key constants for parsing within the generated file
class CommentKey:
	const ENUM: String = "# [Scene Enum]"
	const DATA_BLOCK: String = "# [Scene Data Block]"
	const END_DATA_BLOCK: String = "# [End Scene Data Block]"


## Default value used for invalid scene names
const INVALID_NAME = "INVALID"

## Header text for the autogenerated scene data file
const SCENE_DATA_HEADER: String = """#
# This file is autogenerated by the Scene Manager plugin.
# DO NOT EDIT.
#
@tool
extends Node

"""
const AF = preload("uid://dlgh4u64a7qxk")


## Key constants for internal dictionary storage
class Key:
	const INCLUDE_LIST = "_include_list"
	const SCENE_DATA = "_scenes"
	const SECTIONS = "_sections"


## Flag indicating whether there are unsaved changes
var _dirty_flag: bool = false:
	set(value):
		if _dirty_flag != value:
			_dirty_flag = value
			on_dirty_flag_changed.emit.call_deferred(value)
	get():
		return _dirty_flag

## List of directory paths to include
var _include_list: Array[String]
## Dictionary of scene data objects keyed by scene UID (int)
var _scenes: Dictionary[int, SMgrDataScene]
## List of section (category) names
var _sections: Array[String]


func _init() -> void:
	data_changed.connect(func() -> void: _dirty_flag = true)


# --- Internal Methods (Private) ---


## Restores an instance from dictionary data
## @param src Source dictionary
## @return Generated SMgrData instance
static func _load_from_dict(src: Dictionary) -> SMgrData:
	var ret := SMgrData.new()
	ret._include_list = AF.convert_to_array_string(src.get(Key.INCLUDE_LIST, []))
	ret._sections = AF.convert_to_array_string(src.get(Key.SECTIONS, []))

	var src_ar: Array = src.get(Key.SCENE_DATA, [])
	for sc_info: Dictionary in src_ar:
		var sc := SMgrDataScene.load_from_dict(sc_info)
		if sc:
			ret._scenes[sc.uid] = sc
	return ret


## Reads a file and extracts the data portion between comments as a dictionary
## @param file_path Path to the file to read
## @return Extracted dictionary data
static func _load_file_as_dict(file_path: String) -> Dictionary:
	var data: Dictionary = {
		Key.INCLUDE_LIST: [],
		Key.SECTIONS: [],
		Key.SCENE_DATA: [],
	}

	if not FileAccess.file_exists(file_path):
		push_warning(
			"Scene Manager: Settings file not found at '%s'. Returning empty data." % file_path
		)
		return data

	var file := FileAccess.open(file_path, FileAccess.READ)
	if file == null:
		printerr(
			(
				"Scene Manager Error: Could not open file at '%s'. Error code: %d"
				% [file_path, FileAccess.get_open_error()]
			)
		)
		return data

	var serialized_data := ""
	var in_data_block := false
	while not file.eof_reached():
		var line := file.get_line()
		if line == CommentKey.END_DATA_BLOCK:
			in_data_block = false
		elif line == CommentKey.DATA_BLOCK:
			in_data_block = true
		elif in_data_block:
			serialized_data += line.strip_escapes()

	if serialized_data == "":
		return data

	# Remove leading/trailing double quotes, restore escapes via c_unescape, then parse
	var raw_string := serialized_data.strip_edges()
	if raw_string.begins_with('"') and raw_string.ends_with('"'):
		raw_string = raw_string.substr(1, raw_string.length() - 2)

	var variant_data := str_to_var(raw_string.c_unescape())

	if variant_data is Dictionary:
		data = variant_data
	else:
		printerr("Scene Manager Error: Failed to parse data block in `scenes.gd`.")

	return data


## Converts the instance state into dictionary format
## @return Converted dictionary
func _save_to_dict() -> Dictionary:
	var ret: Dictionary = {}
	ret[Key.INCLUDE_LIST] = _include_list
	ret[Key.SECTIONS] = _sections

	var scene_ar: Array = []
	for uid in _scenes:
		scene_ar.append(_scenes[uid].save_to_dict())

	ret[Key.SCENE_DATA] = scene_ar
	return ret


## Generates the GDScript source code string for the Scene Manager
## @return Generated script string
func _save_as_string() -> String:
	var ret: String = SCENE_DATA_HEADER
	ret += CommentKey.ENUM + "\n"
	ret += "enum Id \\\n{ \n\tNONE = -1,"

	var num_invalid: int = 0
	for uid in _scenes:
		var sc_name: String = _scenes[uid].name
		if sc_name == "":
			ret += "\n\t%s%d," % [INVALID_NAME, num_invalid]
			num_invalid += 1
		else:
			ret += "\n\t%s," % sc_name.to_upper()

	ret += "\n}\n\n"
	ret += CommentKey.DATA_BLOCK + "\n"
	ret += '"' + var_to_str(_save_to_dict()).c_escape() + '"\n'
	ret += CommentKey.END_DATA_BLOCK + "\n"
	return ret


## Loads data from a file, creates SMgrData, and synchronizes with the current filesystem state
## @param file_path Path to the file to load
## @return Generated SMgrData
static func load_data(file_path: String) -> SMgrData:
	var instance := SMgrData._load_from_dict(_load_file_as_dict(file_path))
	instance.sync_with_filesystem()
	return instance


## Saves the current data as a file to the specified path
## @param path Destination path for saving
func save_data(path: String) -> void:
	var dir := path.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir):
		printerr("Scene Manager Error: Cannot save data. Directory does not exist: ", dir)
		return

	var file := FileAccess.open(path, FileAccess.WRITE)
	if file == null:
		printerr("Scene Manager Error: Failed to open file for writing at ", path)
		return

	file.store_string(_save_as_string())
	_dirty_flag = false


# --- File System Sync ---
## Rescans registered include paths, removes non-existent scenes, and registers new scenes
func sync_with_filesystem() -> void:
	var found_uids: Array[int] = []

	# Scan each path in the include list
	for path in _include_list:
		if DirAccess.dir_exists_absolute(path):
			_scan_and_collect_uids(path, found_uids)
		elif FileAccess.file_exists(path) and path.ends_with(".tscn"):
			var uid := _register_scene_file(path)
			if uid != ResourceUID.INVALID_ID:
				found_uids.append(uid)

	# Remove UIDs that should be under the include list but were not found during the scan
	var uids_to_remove: Array[int] = []
	for uid in _scenes:
		var scene_path := _scenes[uid].path
		# Check if the scene is managed under any of the current include paths
		var is_managed := false
		for inc_path in _include_list:
			if scene_path.begins_with(inc_path):
				is_managed = true
				break

		# If managed but not found on the filesystem, mark for removal
		if is_managed and not uid in found_uids:
			uids_to_remove.append(uid)

	if not uids_to_remove.is_empty():
		for uid in uids_to_remove:
			_scenes.erase(uid)
		data_changed.emit()


## For scanning: Recursively collects UIDs
func _scan_and_collect_uids(dir_path: String, collected_uids: Array[int]) -> void:
	var dir: DirAccess = DirAccess.open(dir_path)
	if not dir:
		return

	dir.list_dir_begin()
	var file_name: String = dir.get_next()
	while file_name != "":
		var full_path: String = dir_path.path_join(file_name)
		if dir.current_is_dir():
			if file_name != "." and file_name != "..":
				_scan_and_collect_uids(full_path, collected_uids)
		elif file_name.ends_with(".tscn"):
			var uid = _register_scene_file(full_path)
			if uid != ResourceUID.INVALID_ID:
				collected_uids.append(uid)
		file_name = dir.get_next()


# --- Section Management ---


## Adds a new section
## @param section_name Name of the section to add
func add_section(section_name: String) -> void:
	if not section_name.is_empty() and not _sections.has(section_name):
		_sections.append(section_name)
		data_changed.emit()


## Removes a section and clears its references from all associated scenes
## @param section_name Name of the section to remove
func remove_section(section_name: String) -> void:
	if _sections.has(section_name):
		_sections.erase(section_name)
	else:
		printerr("Scene Manager Error: Cannot remove section '%s'." % section_name)
		return

	for uid in _scenes:
		var scene_info: SMgrDataScene = _scenes[uid]
		var index := scene_info.sections.find(section_name)
		if index != -1:
			scene_info.sections.remove_at(index)
	data_changed.emit()


# --- Include List Management ---


## Adds an include path and scans the target directory or file
## @param inc_path Path to add
## @return true if successful
func add_include_path(inc_path: String) -> bool:
	var is_dir := DirAccess.dir_exists_absolute(inc_path)
	var is_file := FileAccess.file_exists(inc_path) and inc_path.ends_with(".tscn")

	if not is_dir and not is_file:
		printerr(
			"Scene Manager Error: Path '%s' is not a valid directory or .tscn file." % inc_path
		)
		return false

	if not _include_list.has(inc_path):
		_include_list.append(inc_path)
		if is_dir:
			_scan_dir_recursive(inc_path)
		else:
			_register_scene_file(inc_path)
		data_changed.emit()
		return true

	return false


## Recursively scans a directory and registers .tscn files
## @param dir_path Path to scan
func _scan_dir_recursive(dir_path: String) -> void:
	var dir: DirAccess = DirAccess.open(dir_path)
	if not dir:
		return

	dir.list_dir_begin()
	var file_name: String = dir.get_next()

	while file_name != "":
		var full_path: String = dir_path.path_join(file_name)

		if dir.current_is_dir():
			if file_name != "." and file_name != "..":
				_scan_dir_recursive(full_path)
		elif file_name.ends_with(".tscn"):
			_register_scene_file(full_path)

		file_name = dir.get_next()


## Registers a scene file based on its UID
## @param full_path Full path to the scene file
## @return Registered UID (even if it already existed)
func _register_scene_file(full_path: String) -> int:
	var uid := ResourceLoader.get_resource_uid(full_path)
	if uid == ResourceUID.INVALID_ID:
		return ResourceUID.INVALID_ID

	# Skip if the UID is already registered
	if _scenes.has(uid):
		return uid

	var base_name: String = full_path.get_file().get_basename()
	var scene_name: String = base_name

	# Handle duplicate names to ensure unique Enum keys
	var existing_names: Array = []
	for s in _scenes.values():
		existing_names.append(s.name)

	var counter: int = 1
	while scene_name in existing_names:
		scene_name = base_name + str(counter)
		counter += 1

	var new_scene := SMgrDataScene.new()
	new_scene.name = scene_name
	new_scene.path = full_path
	new_scene.uid = uid  # Stored as an int
	_scenes[uid] = new_scene
	data_changed.emit()
	return uid


## Removes an include path and unregisters all scenes under it
## @param scene_path Path to remove
func remove_include_path(scene_path: String) -> void:
	if _include_list.has(scene_path):
		_include_list.erase(scene_path)
	else:
		printerr(
			(
				"Scene Manager Error: Cannot remove include path. Path '%s' is not in the list."
				% scene_path
			)
		)
		return

	var uids_to_remove: Array[int] = []
	for uid in _scenes:
		if _scenes[uid].path.begins_with(scene_path):
			uids_to_remove.append(uid)

	for uid in uids_to_remove:
		_scenes.erase(uid)

	data_changed.emit()


# --- Data Queries (Getters) ---
func _get_scene_from_enum(scene: Scenes.Id) -> SMgrDataScene:
	if scene == Scenes.Id.NONE:
		return null
	var key_str: String = Scenes.Id.keys()[scene + 1]
	for uid in _scenes:
		var sc := _scenes[uid]
		if SceneManagerUtils.sanitize_as_enum_string(sc.name) == key_str:
			return sc
	return null


## Retrieves scene data by UID
## @param uid Scene UID (int)
## @return Corresponding SMgrDataScene
func get_scene_from_uid(uid: int) -> SMgrDataScene:
	return _scenes.get(uid, null)


## Retrieves a scene path from an enum key
## @param scene Scene enum
## @return Scene path string
func get_scene_path_from_enum(scene: Scenes.Id) -> String:
	var sc := _get_scene_from_enum(scene)
	return sc.path if sc else ""


## Retrieves an enum key from a scene path
## @param path Full path of the scene
## @return Corresponding Id
func get_scene_enum_by_path(path: String) -> Scenes.Id:
	for uid in _scenes:
		if _scenes[uid].path == path:
			var enum_name := SceneManagerUtils.sanitize_as_enum_string(_scenes[uid].name)
			return Scenes.Id.get(enum_name, Scenes.Id.NONE)
	return Scenes.Id.NONE


## Retrieves the full include list
## @return Array of paths
func get_include_list() -> Array[String]:
	return _include_list


## Retrieves the full list of sections
## @return Array of section names
func get_sections_list() -> Array[String]:
	return _sections


## Internal method to extract scenes into an array based on a comparison function
## @param cmp Callable for evaluation
## @return Filtered array of scenes
func _get_scenes(cmp: Callable) -> Array[SMgrDataScene]:
	var ret: Array[SMgrDataScene] = []
	for uid in _scenes:
		var sc := _scenes[uid]
		if cmp.call(sc):
			ret.append(sc)
	return ret


## Retrieves all registered scenes
## @return Array of scene data
func get_scenes_all() -> Array[SMgrDataScene]:
	return _get_scenes(func(sc: SMgrDataScene) -> bool: return true)


## Retrieves scenes that are not categorized
## @return Array of scene data
func get_scenes_uncategorized() -> Array[SMgrDataScene]:
	return _get_scenes(func(sc: SMgrDataScene) -> bool: return sc.sections.is_empty())


## Retrieves scenes that are categorized
## @return Array of scene data
func get_scenes_categorized() -> Array[SMgrDataScene]:
	return _get_scenes(func(sc: SMgrDataScene) -> bool: return not sc.sections.is_empty())


## Retrieves scenes belonging to a specific section
## @param section_name Name of the section to search for
## @return Array of scene data
func get_scenes_with_section(section_name: String) -> Array[SMgrDataScene]:
	return _get_scenes(func(sc: SMgrDataScene) -> bool: return section_name in sc.sections)


## Assigns a scene to a specific section
## @param uid Scene UID (int)
## @param section_name Name of the section to assign
func add_scene_to_section(uid: int, section_name: String) -> void:
	if _scenes.has(uid):
		var sc: SMgrDataScene = _scenes[uid]
		if not section_name in sc.sections:
			sc.sections.append(section_name)
			data_changed.emit()


## Removes a specific section assignment from a scene
## @param uid Scene UID (int)
## @param section_name Name of the section to remove
func remove_scene_from_section(uid: int, section_name: String) -> void:
	if _scenes.has(uid):
		var sc: SMgrDataScene = _scenes[uid]
		var idx := sc.sections.find(section_name)
		if idx != -1:
			sc.sections.remove_at(idx)
			data_changed.emit()


## Retrieves scene data by specifying a name
## @param scene_name Scene name
## @return Corresponding SMgrDataScene
func get_scene_by_name(scene_name: String) -> SMgrDataScene:
	for uid in _scenes:
		var sc: SMgrDataScene = _scenes[uid]
		if sc.name == scene_name:
			return sc
	return null


## Changes the display name of a scene
## @param uid Scene UID (int)
## @param new_name New display name
func change_scene_name(uid: int, new_name: String) -> void:
	if _scenes.has(uid):
		var sc: SMgrDataScene = _scenes[uid]
		if not new_name.is_empty() and sc.name != new_name:
			sc.name = new_name
			data_changed.emit()


## Retrieves the current dirty flag
## @return true if there are changes
func get_dirty_flag() -> bool:
	return _dirty_flag
