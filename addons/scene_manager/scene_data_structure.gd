@tool
class_name SMgrData
extends RefCounted


class CommentKey:
	const ENUM: String = "# [Scene Enum]"
	const DICTIONARY: String = "# [Scene Dictionary]"
	const END_DICTIONARY: String = "# [End Scene Dictionary]"


const INVALID_NAME = "INVALID"

# scene.gd autogen file tags
const SCENE_DATA_HEADER: String = """#
# This file is autogenerated by the Scene Manager plugin.
# DO NOT EDIT.
#
@tool
extends Node

"""
const AF = preload("./aux_func.gd")


class Key:
	const INCLUDE_LIST = "_include_list"
	const SCENE_DATA = "_scenes"
	const SECTIONS = "_sections"


class Scene:
	class Key:
		const SECTIONS = "sections"
		const PATH = "value"

	var sections: Array[String]
	var path: String

	static func load_from_dict(src: Dictionary) -> Scene:
		var ret := Scene.new()
		ret.sections = AF.convert_to_array_string(src.get(Scene.Key.SECTIONS, []))
		ret.path = src.get(Scene.Key.PATH, "")
		return ret

	func save_to_dict() -> Dictionary:
		return {
			Scene.Key.SECTIONS: sections,
			Scene.Key.PATH: path,
		}


# include path list
var include_list: Array[String]
# scene_name -> Scene class
var scenes: Dictionary[String, Scene]
# main sections list
var sections: Array[String]

# scene_path -> Scene map
var cache_path_to_scene: Dictionary[String, Scene]
var has_changes: bool:
	get():
		return _has_changes

var _has_changes: bool = false


# --- Internal Methods (Private) ---
func _make_cache() -> void:
	cache_path_to_scene.clear()
	for sc_name in scenes:
		var scene_info := scenes[sc_name]
		cache_path_to_scene[scene_info.path] = scene_info


static func _load_from_dict(src: Dictionary) -> SMgrData:
	var ret := SMgrData.new()
	ret.include_list = AF.convert_to_array_string(src.get(Key.INCLUDE_LIST, []))
	ret.sections = AF.convert_to_array_string(src.get(Key.SECTIONS, []))

	var src_sc: Dictionary = src.get(Key.SCENE_DATA, {})
	for sc_name: String in src_sc:
		ret.scenes[sc_name] = Scene.load_from_dict(src_sc[sc_name])
	ret._make_cache()
	return ret


static func _load_file_as_dict(file_path: String) -> Dictionary:
	var data: Dictionary = {
		Key.INCLUDE_LIST: [],
		Key.SECTIONS: [],
		Key.SCENE_DATA: {},
	}

	if not FileAccess.file_exists(file_path):
		push_warning(
			"Scene Manager: Settings file not found at '%s'. Returning empty data." % file_path
		)
		return data

	var file := FileAccess.open(file_path, FileAccess.READ)
	if file == null:
		printerr(
			(
				"Scene Manager Error: Could not open file at '%s'. Error code: %d"
				% [file_path, FileAccess.get_open_error()]
			)
		)
		return data

	var dictionary := ""
	var in_dictionary := false
	while not file.eof_reached():
		var line := file.get_line()
		if line == CommentKey.END_DICTIONARY:
			in_dictionary = false
		elif line == CommentKey.DICTIONARY:
			in_dictionary = true
			file.get_line()  # skip to json
		elif in_dictionary:
			dictionary += line.strip_escapes()

	if dictionary == "":
		return data

	var json := JSON.new()
	var err := json.parse(dictionary)
	if err != OK:
		printerr(
			(
				"Scene Manager Error: `scenes.gd` File is corrupted. (Line %d: %s)"
				% [json.get_error_line(), json.get_error_message()]
			)
		)
		return data

	if json.data is Dictionary:
		data = json.data
	return data


func _save_to_dict() -> Dictionary:
	var ret: Dictionary = {}
	ret[Key.INCLUDE_LIST] = include_list
	ret[Key.SECTIONS] = sections

	var scene_dict: Dictionary = {}
	for sc_name in scenes:
		scene_dict[sc_name] = scenes[sc_name].save_to_dict()

	ret[Key.SCENE_DATA] = scene_dict
	return ret


func _save_as_string() -> String:
	# Generates the scene.gd file with all the scene data
	var ret: String = SCENE_DATA_HEADER

	# --- Enums ---
	# Convert the keys of the dictionary into an enum
	ret += CommentKey.ENUM + "\n"
	ret += "enum SceneName \\\n{ \n\tNONE = -1, "

	# Keep track of invalid enums so there aren't blank names that make the generated enum invalid
	var num_invalid: int = 0
	for sc_name: String in self.scenes.keys():
		if sc_name == "":
			ret += "\n\t%s%d, " % [INVALID_NAME, num_invalid]
			num_invalid += 1
		else:
			ret += "\n\t%s, " % sc_name.to_upper()

	ret += "\n}\n\n"
	# ---

	# --- Other Data ---
	ret += CommentKey.DICTIONARY + "\n"
	ret += "var scenes: Dictionary = \\\n"
	ret += JSON.stringify(_save_to_dict(), "\t") + "\n"
	ret += CommentKey.END_DICTIONARY + "\n"
	# ---
	return ret


# --- File I/O (Persistence) ---
static func load_data(file_path: String) -> SMgrData:
	return SMgrData._load_from_dict(_load_file_as_dict(file_path))


func save_data(path: String) -> void:
	# Generate an error if the directory does not exist
	var dir := path.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir):
		printerr("Scene Manager Error: Cannot save data. Directory does not exist: ", dir)
		return

	var file := FileAccess.open(path, FileAccess.WRITE)
	if file == null:
		printerr(
			"Scene Manager Error: Failed to open file for writing at ",
			path,
			". Error code: ",
			FileAccess.get_open_error()
		)
		return

	file.store_string(_save_as_string())
	_has_changes = false


# --- Section Management ---
func add_section(section_name: String) -> void:
	if section_name != "" and not sections.has(section_name):
		sections.append(section_name)
		_has_changes = true


func remove_section(section_name: String) -> void:
	# remove from section list
	if sections.has(section_name):
		sections.erase(section_name)
		_has_changes = true
	else:
		printerr(
			(
				"Scene Manager Error: Cannot remove section. Section '%s' does not exist."
				% section_name
			)
		)
		return

	# Also remove from section references held by each scene
	for sc_name in scenes:
		var scene_info: Scene = scenes[sc_name]
		var index := scene_info.sections.find(section_name)
		if index != -1:
			scene_info.sections.remove_at(index)
			_has_changes = true


# --- Scene Management ---
func change_scene_name(old_name: String, new_name: String) -> void:
	if not scenes.has(old_name) or new_name == "" or scenes.has(new_name):
		return

	var scene_info := scenes[old_name]
	scenes.erase(old_name)
	scenes[new_name] = scene_info
	_has_changes = true


func add_scene_to_section(scene_path: String, section_name: String) -> void:
	if not sections.has(section_name):
		printerr(
			(
				"Scene Manager Error: Cannot add scene to section. Section '%s' does not exist."
				% section_name
			)
		)
		return

	if not cache_path_to_scene.has(scene_path):
		return

	var scene_info: Scene = cache_path_to_scene[scene_path]
	if not scene_info.sections.has(section_name):
		scene_info.sections.append(section_name)
		_has_changes = true


func remove_scene_from_section(scene_path: String, section_name: String) -> void:
	if not sections.has(section_name):
		printerr(
			(
				"Scene Manager Error: Cannot remove scene from section. Section '%s' does not exist."
				% section_name
			)
		)
		return

	if not cache_path_to_scene.has(scene_path):
		return

	var scene_info: Scene = cache_path_to_scene[scene_path]
	var index := scene_info.sections.find(section_name)
	if index != -1:
		scene_info.sections.remove_at(index)
		_has_changes = true


# --- Include List & Cache Management ---


func add_include_path(inc_path: String) -> void:
	if not DirAccess.dir_exists_absolute(inc_path):
		printerr(
			(
				"Scene Manager Error: Cannot add include path. Directory '%s' does not exist."
				% inc_path
			)
		)
		return

	if not include_list.has(inc_path):
		include_list.append(inc_path)
		_has_changes = true


func remove_include_path(scene_path: String) -> void:
	if include_list.has(scene_path):
		include_list.erase(scene_path)
		_has_changes = true
	else:
		printerr(
			(
				"Scene Manager Error: Cannot remove include path. Path '%s' is not in the list."
				% scene_path
			)
		)
		return

	# Delete all scenes under the path
	var keys_to_remove: Array[String] = []
	for sc_name in scenes:
		if scenes[sc_name].path.begins_with(scene_path):
			keys_to_remove.append(sc_name)

	for sc_name in keys_to_remove:
		var scene_info = scenes[sc_name]
		# Also deleted from cache (map from path to scene)
		if cache_path_to_scene.has(scene_info.path):
			cache_path_to_scene.erase(scene_info.path)
		# Delete from main data
		scenes.erase(sc_name)


# --- Data Queries (Getters) ---
func get_scene_sections_by_path(scene_path: String) -> Array[String]:
	if cache_path_to_scene.has(scene_path):
		return cache_path_to_scene[scene_path].sections

	printerr(
		"Scene Manager Error: Cannot get sections. Scene path '%s' does not exist." % scene_path
	)
	return []


func has_section(scene_path: String) -> bool:
	if cache_path_to_scene.has(scene_path):
		return not cache_path_to_scene[scene_path].sections.is_empty()

	printerr(
		"Scene Manager Error: Cannot check sections. Scene path '%s' does not exist." % scene_path
	)
	return false


func get_scene_path_from_enum(key: Scenes.SceneName) -> String:
	var key_str: String = Scenes.SceneName.keys()[key]
	for sc_name in scenes:
		if SceneManagerUtils.sanitize_as_enum_string(sc_name) == key_str:
			return scenes[sc_name].path
	return ""
